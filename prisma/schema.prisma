generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                         String                    @id @default(cuid())
  email                      String                    @unique
  hashedPassword             String?
  createdAt                  DateTime                  @default(now())
  updatedAt                  DateTime                  @updatedAt
  lastLoginAt                DateTime?
  emailVerified              Boolean                   @default(false)
  emailVerifiedAt            DateTime?
  isBanned                   Boolean                   @default(false)
  bannedAt                   DateTime?
  bannedReason               String?
  lockedUntil                DateTime?                 // Account lockout for failed logins
  lockoutCount               Int                       @default(0) // Number of times account has been locked
  mfaEnabled                 Boolean                   @default(false)
  mfaSecret                  String?                   @db.VarChar(255) // Encrypted TOTP secret
  mfaBackupCodes             String[]                  // Hashed backup codes
  passwordHistory            String[]                  // Last 5 password hashes
  passwordChangedAt          DateTime?                 // Last password change
  lastActiveAt               DateTime?
  sessionVersion             Int                       @default(0) // Incremented on privilege changes to force session rotation
  aacVocabulary              AACVocabulary[]
  aiConversations            AIConversation[]
  aiMessages                 AIMessage[]
  auditLogs                  AuditLog[]
  blockedByUsers             BlockedUser[]             @relation("BlockedUser")
  blockedUsers               BlockedUser[]             @relation("BlockedByUser")
  bookmarks                  Bookmark[]
  comments                   Comment[]
  receivedConnectionRequests ConnectionRequest[]       @relation("ConnectionRequestReceiver")
  sentConnectionRequests     ConnectionRequest[]       @relation("ConnectionRequestSender")
  connectionsA               Connection[]              @relation("ConnectionUserA")
  connectionsB               Connection[]              @relation("ConnectionUserB")
  conversationParticipants   ConversationParticipant[]
  dailyWins                  DailyWin[]
  emailVerifications         EmailVerification[]
  emailVerificationTokens    EmailVerificationToken[]
  messageRateLimits          MessageRateLimit[]
  messageReportsReceived     MessageReport[]           @relation("MessageReported")
  messageReportsFiled        MessageReport[]           @relation("MessageReporter")
  sentMessages               Message[]
  modActionLogs              ModActionLog[]            @relation("ModActionLogModerator")
  moderationActions          ModerationAction[]        @relation("ModeratorUser")
  moderationTargets          ModerationAction[]        @relation("TargetUser")
  notifications              Notification[]
  ownerNotes                 OwnerNote[]
  passwordResetTokens        PasswordResetToken[]
  posts                      Post[]
  profile                    Profile?
  claimedProviders           Provider[]
  providerReviews            ProviderReview[]
  rateLimitLogs              RateLimitLog[]
  reports                    Report[]                  @relation("ReporterUser")
  createdResources           Resource[]
  savedResources             SavedResource[]
  screeningResults           ScreeningResult[]
  searchQueries              SearchQuery[]
  sensitiveAccessLogs        SensitiveAccessLog[]
  securityAlerts             SecurityAlert[]
  consents                   UserConsent[]
  userFinder                 UserFinder?
  userRoles                  UserRole[]
  sessions                   UserSession[]
  votes                      Vote[]

  @@index([email])
  @@index([createdAt])
}

model UserFinder {
  id          String   @id @default(cuid())
  userId      String   @unique
  username    String   @unique
  displayName String
  keywords    String
  avatarUrl   String?
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([keywords])
}

model EmailVerification {
  id         String    @id @default(cuid())
  email      String
  otp        String    @db.VarChar(6)
  userId     String?
  expiresAt  DateTime
  verified   Boolean   @default(false)
  verifiedAt DateTime?
  createdAt  DateTime  @default(now())
  user       User?     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([otp])
  @@index([expiresAt])
  @@index([verified])
  @@index([userId], map: "idx_email_verification_user_id")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tokenHash])
  @@index([expiresAt])
  @@index([userId])
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  createdAt DateTime  @default(now())
  usedAt    DateTime?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Profile {
  id                String    @id @default(cuid())
  userId            String    @unique
  username          String    @unique @db.VarChar(50)
  displayName       String    @db.VarChar(255)
  bio               String?
  avatarUrl         String?
  location          String?
  website           String?
  verifiedTherapist Boolean   @default(false)
  verifiedAt        DateTime?
  shadowbanned      Boolean   @default(false)
  shadowbannedAt    DateTime?
  notificationPrefs Json      @default("{}")
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([username])
  @@index([verifiedTherapist])
  @@index([shadowbanned])
}

model UserRole {
  id        String   @id @default(cuid())
  userId    String
  role      Role
  grantedAt DateTime @default(now())
  grantedBy String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
  @@index([userId])
  @@index([role])
  @@index([createdAt])
}

model AuditLog {
  id         String   @id @default(cuid())
  userId     String
  action     String
  targetType String?
  targetId   String?
  changes    Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([targetType])
  @@index([targetId])
  @@index([createdAt])
}

model Category {
  id          String   @id @default(cuid())
  name        String   @unique @db.VarChar(100)
  slug        String   @unique @db.VarChar(100)
  description String?
  icon        String?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  posts       Post[]

  @@index([slug])
  @@index([order])
}

model Tag {
  id          String   @id @default(cuid())
  name        String   @unique @db.VarChar(50)
  slug        String   @unique @db.VarChar(50)
  description String?
  color       String?  @db.VarChar(7)
  createdAt   DateTime @default(now())
  posts       Post[]   @relation("PostToTag")

  @@index([slug])
  @@index([name])
}

model Post {
  id                String             @id @default(cuid())
  title             String             @db.VarChar(255)
  content           String
  authorId          String?
  isAnonymous       Boolean            @default(false)
  categoryId        String
  status            PostStatus         @default(ACTIVE)
  viewCount         Int                @default(0)
  commentCount      Int                @default(0)
  voteScore         Int                @default(0)
  isPinned          Boolean            @default(false)
  isLocked          Boolean            @default(false)
  pinnedAt          DateTime?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  images            String[]
  bookmarks         Bookmark[]
  comments          Comment[]
  moderationActions ModerationAction[]
  author            User?              @relation(fields: [authorId], references: [id])
  category          Category           @relation(fields: [categoryId], references: [id])
  tags              Tag[]              @relation("PostToTag")

  @@index([authorId])
  @@index([categoryId])
  @@index([status])
  @@index([createdAt])
  @@index([updatedAt])
  @@index([viewCount])

  // NEW COMPOSITE INDEXES for query optimization (Phase 7.1.2)
  @@index([status, createdAt], name: "idx_post_status_created")
  @@index([categoryId, status, createdAt], name: "idx_post_category_status_created")
  @@index([authorId, createdAt], name: "idx_post_author_created")
  @@index([voteScore, createdAt], name: "idx_post_score_created")
}

model Comment {
  id                String             @id @default(cuid())
  content           String
  authorId          String
  postId            String
  parentCommentId   String?
  status            CommentStatus      @default(ACTIVE)
  isAnonymous       Boolean            @default(false)
  voteScore         Int                @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  author            User               @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentComment     Comment?           @relation("ChildComments", fields: [parentCommentId], references: [id], onDelete: Cascade)
  childComments     Comment[]          @relation("ChildComments")
  post              Post               @relation(fields: [postId], references: [id], onDelete: Cascade)
  moderationActions ModerationAction[]

  @@index([authorId])
  @@index([postId])
  @@index([parentCommentId])
  @@index([status])
  @@index([createdAt])

  // NEW COMPOSITE INDEXES for query optimization (Phase 7.1.2)
  @@index([postId, status, createdAt], name: "idx_comment_post_status_created")
  @@index([parentCommentId, createdAt], name: "idx_comment_parent_created")
  @@index([authorId, createdAt], name: "idx_comment_author_created")
}

model Vote {
  id         String   @id @default(cuid())
  userId     String
  targetType VoteType
  targetId   String
  value      Int      @db.SmallInt
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, targetId, targetType])
  @@index([userId])
  @@index([targetId])
  @@index([targetType])
  @@index([createdAt])

  // NEW COMPOSITE INDEXES for query optimization (Phase 7.1.2)
  @@index([userId, targetType], name: "idx_vote_user_type")
  @@index([targetId, targetType], name: "idx_vote_target")
}

model Bookmark {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@index([createdAt])
}

model Report {
  id          String           @id @default(cuid())
  reporterId  String
  targetType  ReportTargetType
  targetId    String
  reason      ReportReason
  description String?
  status      ReportStatus     @default(OPEN)
  reviewedBy  String?
  reviewedAt  DateTime?
  notes       String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  reporter    User             @relation("ReporterUser", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([reporterId])
  @@index([targetType])
  @@index([targetId])
  @@index([status])
  @@index([createdAt])
}

model ModerationAction {
  id           String               @id @default(cuid())
  action       ModerationActionType
  actorId      String
  targetUserId String?
  postId       String?
  commentId    String?
  notes        String?
  createdAt    DateTime             @default(now())
  actor        User                 @relation("ModeratorUser", fields: [actorId], references: [id], onDelete: Cascade)
  comment      Comment?             @relation(fields: [commentId], references: [id], onDelete: Cascade)
  post         Post?                @relation(fields: [postId], references: [id], onDelete: Cascade)
  targetUser   User?                @relation("TargetUser", fields: [targetUserId], references: [id])

  @@index([actorId])
  @@index([targetUserId])
  @@index([postId])
  @@index([commentId])
  @@index([action])
  @@index([createdAt])
}

model ModActionLog {
  id          String               @id @default(cuid())
  actionType  ModerationActionType
  targetType  ReportTargetType
  targetId    String
  targetTitle String?              @db.VarChar(255)
  moderatorId String
  reason      String?              @db.VarChar(255)
  notes       String?
  createdAt   DateTime             @default(now())
  moderator   User                 @relation("ModActionLogModerator", fields: [moderatorId], references: [id], onDelete: Cascade)

  @@index([moderatorId])
  @@index([actionType])
  @@index([targetType])
  @@index([targetId])
  @@index([createdAt])
}

model Provider {
  id              String                 @id @default(cuid())
  externalSource  ProviderSource
  externalId      String?                @db.VarChar(255)
  name            String                 @db.VarChar(255)
  phone           String?                @db.VarChar(20)
  address         String?
  city            String?                @db.VarChar(100)
  state           String?                @db.VarChar(50)
  zipCode         String?                @db.VarChar(10)
  latitude        Float?
  longitude       Float?
  website         String?
  email           String?
  specialties     ProviderSpecialty[]
  rating          Decimal?               @db.Decimal(3, 2)
  totalReviews    Int                    @default(0)
  isVerified      Boolean                @default(false)
  verifiedAt      DateTime?
  claimedByUserId String?
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  claimedByUser   User?                  @relation(fields: [claimedByUserId], references: [id])
  claimRequests   ProviderClaimRequest[]
  reviews         ProviderReview[]

  @@unique([externalSource, externalId])
  @@index([externalSource])
  @@index([name])
  @@index([city])
  @@index([isVerified])
  @@index([createdAt])
  @@index([latitude, longitude])
  @@index([claimedByUserId], map: "idx_provider_claimed_by_user_id")
}

model ProviderReview {
  id         String   @id @default(cuid())
  providerId String
  authorId   String
  rating     Int      @db.SmallInt
  content    String?
  status     String   @default("ACTIVE")
  helpful    Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  author     User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, authorId])
  @@index([providerId])
  @@index([authorId])
  @@index([rating])
  @@index([createdAt])
}

model ProviderClaimRequest {
  id              String              @id @default(cuid())
  providerId      String
  requesterUserId String
  status          ProviderClaimStatus @default(PENDING)
  message         String?
  reviewedAt      DateTime?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  provider        Provider            @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([providerId, requesterUserId])
  @@index([providerId])
  @@index([status])
  @@index([createdAt])
}

model AIConversation {
  id        String      @id @default(cuid())
  userId    String
  title     String      @db.VarChar(255)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  AIMessage[]

  @@index([userId])
  @@index([createdAt])
}

model AIMessage {
  id             String         @id @default(cuid())
  conversationId String
  userId         String
  role           String
  content        String
  tokens         Int?
  createdAt      DateTime       @default(now())
  conversation   AIConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([userId])
  @@index([createdAt])
}

/// Async AI job queue for non-blocking chat processing
model AIJob {
  id             String    @id @default(cuid())
  userId         String
  conversationId String
  /// ENCRYPTED: Contains conversation messages
  messages       String    @db.Text
  status         String    // pending, processing, completed, failed
  /// ENCRYPTED: Contains AI response
  result         String?   @db.Text
  error          String?
  retryCount     Int       @default(0)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  startedAt      DateTime?
  completedAt    DateTime?

  @@index([userId])
  @@index([status])
  @@index([createdAt])

  // NEW COMPOSITE INDEXES for query optimization (Phase 7.1.2)
  @@index([status, createdAt], name: "idx_aijob_status_created")
  @@index([userId, status], name: "idx_aijob_user_status")
  @@index([conversationId], name: "idx_aijob_conversation")
}

/// Dead Letter Queue for failed AI jobs that exceeded max retries
model AIJobDeadLetter {
  id             String    @id @default(cuid())
  originalJobId  String
  userId         String
  conversationId String
  /// ENCRYPTED: Contains conversation messages
  messages       String    @db.Text
  error          String    @db.Text
  retryCount     Int       @default(0)
  failedAt       DateTime  @default(now())
  /// Whether this job has been manually retried
  retried        Boolean   @default(false)
  retriedAt      DateTime?
  /// ID of the new job created when retrying
  newJobId       String?

  @@index([userId])
  @@index([retried])
  @@index([failedAt])
}

/// AI Token usage tracking for cost monitoring
model AITokenUsage {
  id             String   @id @default(cuid())
  userId         String
  jobId          String
  inputTokens    Int
  outputTokens   Int
  totalTokens    Int
  /// Estimated cost in USD
  estimatedCost  Float    @default(0)
  provider       String   // groq, gemini, fallback
  createdAt      DateTime @default(now())

  @@index([userId])
  @@index([jobId])
  @@index([provider])
  @@index([createdAt])
}

/// AI Interaction Audit Log - tracks all AI interactions for compliance
model AIInteractionLog {
  id             String   @id @default(cuid())
  userId         String
  jobId          String
  conversationId String
  action         String   // REQUEST, RESPONSE, ERROR, SAFETY_BLOCK, RATE_LIMIT, COST_LIMIT
  /// Redacted messages (PII removed)
  messages       Json?
  /// Redacted response (PII removed)
  response       String?  @db.Text
  provider       String?
  model          String?
  inputTokens    Int?
  outputTokens   Int?
  totalTokens    Int?
  cost           Float?
  latencyMs      Int?
  error          String?
  safetyFlags    Json?
  ipAddress      String?
  userAgent      String?
  metadata       Json?
  createdAt      DateTime @default(now())

  @@index([userId])
  @@index([jobId])
  @@index([conversationId])
  @@index([action])
  @@index([createdAt])
}

model RateLimitLog {
  id         String   @id @default(cuid())
  userId     String
  actionType String   @db.VarChar(50)
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([actionType])
  @@index([createdAt])
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  payload   Json
  readAt    DateTime?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([readAt])
  @@index([createdAt])

  // NEW COMPOSITE INDEXES for query optimization (Phase 7.1.2)
  @@index([userId, readAt], name: "idx_notification_user_read")
  @@index([userId, createdAt], name: "idx_notification_user_created")
}

model Resource {
  id        String           @id @default(cuid())
  title     String           @db.VarChar(255)
  content   String?
  link      String?
  category  ResourceCategory
  createdBy String
  status    String           @default("ACTIVE")
  views     Int              @default(0)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  creator   User             @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  savedBy   SavedResource[]

  @@index([createdBy])
  @@index([category])
  @@index([status])
  @@index([createdAt])
}

model SavedResource {
  id         String   @id @default(cuid())
  userId     String
  resourceId String
  createdAt  DateTime @default(now())
  resource   Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, resourceId])
  @@index([userId])
  @@index([resourceId])
}

model DataOwner {
  id           String    @id @default(cuid())
  teamName     String    @unique @db.VarChar(100)
  contactEmail String    @db.VarChar(255)
  slackChannel String?   @db.VarChar(100)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  datasets     Dataset[]

  @@index([teamName])
}

model Dataset {
  id              String                @id @default(cuid())
  name            String                @unique @db.VarChar(255)
  description     String
  domain          String                @db.VarChar(100)
  ownerTeam       String
  sensitivity     DataSensitivity       @default(INTERNAL)
  tags            String[]
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  retentionPolicy String?               @db.VarChar(100)
  updateFrequency String?               @db.VarChar(100)
  lineageNodes    DataLineageNode[]
  qualityRules    DataQualityRule[]
  owner           DataOwner             @relation(fields: [ownerTeam], references: [teamName])
  fields          DatasetField[]
  glossaryTerms   DatasetGlossaryTerm[]

  @@index([domain])
  @@index([sensitivity])
  @@index([name])
  @@index([ownerTeam])
  @@index([createdAt])
}

model DatasetField {
  id          String          @id @default(cuid())
  datasetId   String
  name        String          @db.VarChar(255)
  type        String          @db.VarChar(100)
  description String
  isNullable  Boolean         @default(true)
  sensitivity DataSensitivity @default(INTERNAL)
  examples    String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  dataset     Dataset         @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@unique([datasetId, name])
  @@index([datasetId])
  @@index([sensitivity])
  @@index([name])
}

model BusinessGlossaryTerm {
  id         String                @id @default(cuid())
  name       String                @unique @db.VarChar(100)
  definition String
  examples   String?
  createdAt  DateTime              @default(now())
  updatedAt  DateTime              @updatedAt
  datasets   DatasetGlossaryTerm[]

  @@index([name])
}

model DatasetGlossaryTerm {
  id        String               @id @default(cuid())
  datasetId String
  termId    String
  createdAt DateTime             @default(now())
  dataset   Dataset              @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  term      BusinessGlossaryTerm @relation(fields: [termId], references: [id], onDelete: Cascade)

  @@unique([datasetId, termId])
  @@index([datasetId])
  @@index([termId])
}

model TherapySession {
  id            String      @id @default(cuid())
  userId        String
  childName     String      @db.VarChar(100)
  therapistName String      @db.VarChar(100)
  therapyType   TherapyType
  sessionDate   DateTime
  duration      Int         @default(60)
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  notes         String?     @db.Text
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  wentWell      String?     @db.Text
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  toWorkOn      String?     @db.Text
  mood          Int?        @db.SmallInt
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([userId])
  @@index([sessionDate])
  @@index([therapyType])
  @@index([createdAt])

  // NEW COMPOSITE INDEX for query optimization (Phase 7.1.2)
  @@index([userId, sessionDate], name: "idx_therapy_user_date")
}

model EmergencyCard {
  id                     String   @id @default(cuid())
  userId                 String
  childName              String   @db.VarChar(100)
  childAge               Int?
  diagnosis              String?  @db.VarChar(255)
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  triggers               String?  @db.Text
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  calmingStrategies      String?  @db.Text
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  communication          String?  @db.Text
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  medications            String?  @db.Text
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  allergies              String?  @db.Text
  emergencyContact1Name  String?  @db.VarChar(100)
  emergencyContact1Phone String?  @db.VarChar(20)
  emergencyContact2Name  String?  @db.VarChar(100)
  emergencyContact2Phone String?  @db.VarChar(20)
  doctorName             String?  @db.VarChar(100)
  doctorPhone            String?  @db.VarChar(20)
  /// ENCRYPTED: Contains sensitive PHI - decrypt with FieldEncryption.decrypt()
  additionalNotes        String?  @db.Text
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
}

model Conversation {
  id           String                    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  createdAt    DateTime                  @default(now()) @map("created_at") @db.Timestamptz(6)
  participants ConversationParticipant[]
  messages     Message[]

  @@map("Conversations")
}

model ConversationParticipant {
  conversationId String       @map("conversation_id") @db.Uuid
  userId         String       @map("user_id")
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz(6)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@id([conversationId, userId])
  @@index([userId], map: "idx_conversation_participants_user_id")
  @@map("ConversationParticipants")
}

model Message {
  id             String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId String?       @map("conversation_id") @db.Uuid
  senderId       String?       @map("sender_id")
  content        String?
  imageUrl       String?       @map("image_url")
  createdAt      DateTime      @default(now()) @map("created_at") @db.Timestamptz(6)
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  sender         User?         @relation(fields: [senderId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([conversationId], map: "idx_messages_conversation_id")
  @@index([createdAt], map: "idx_messages_created_at")
  @@index([senderId], map: "idx_messages_sender_id")

  // NEW COMPOSITE INDEX for query optimization (Phase 7.1.2)
  @@index([conversationId, createdAt], map: "idx_messages_conversation_created")

  @@map("Messages")
}

model BlockedUser {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())
  blocked   User     @relation("BlockedUser", fields: [blockedId], references: [id], onDelete: Cascade)
  blocker   User     @relation("BlockedByUser", fields: [blockerId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

model MessageReport {
  id             String       @id @default(cuid())
  reporterId     String
  reportedUserId String
  conversationId String?
  reason         String       @db.VarChar(255)
  description    String?
  status         ReportStatus @default(OPEN)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  reportedUser   User         @relation("MessageReported", fields: [reportedUserId], references: [id], onDelete: Cascade)
  reporter       User         @relation("MessageReporter", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([reporterId])
  @@index([reportedUserId])
  @@index([status])
  @@index([createdAt])
}

model MessageRateLimit {
  id         String   @id @default(cuid())
  userId     String
  actionType String   @db.VarChar(50)
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([actionType])
  @@index([createdAt])
}

model ConnectionRequest {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  senderId   String?  @map("sender_id")
  receiverId String?  @map("receiver_id")
  message    String?
  status     String?  @default("PENDING")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  receiver   User?    @relation("ConnectionRequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  sender     User?    @relation("ConnectionRequestSender", fields: [senderId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([senderId, receiverId])
  @@index([receiverId], map: "idx_connection_requests_receiver_id")
  @@index([status], map: "idx_connection_requests_status")

  // NEW COMPOSITE INDEXES for query optimization (Phase 7.1.2)
  @@index([receiverId, status], map: "idx_connection_requests_receiver_status")
  @@index([senderId, status], map: "idx_connection_requests_sender_status")

  @@map("ConnectionRequests")
}

model Connection {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userA     String?  @map("user_a")
  userB     String?  @map("user_b")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  user1     User?    @relation("ConnectionUserA", fields: [userA], references: [id], onDelete: Cascade, onUpdate: NoAction)
  user2     User?    @relation("ConnectionUserB", fields: [userB], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([userA, userB])
  @@index([userA], map: "idx_connections_user_a")
  @@index([userB], map: "idx_connections_user_b")
  @@map("Connections")
}

model DailyWin {
  id        String   @id @default(cuid())
  userId    String
  date      DateTime @db.Date
  content   String
  mood      Int?     @db.SmallInt
  category  String?  @db.VarChar(50)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([date])
  @@index([createdAt])

  // NEW COMPOSITE INDEXES for query optimization (Phase 7.1.2)
  @@index([userId, date], name: "idx_dailywin_user_date")
  @@index([userId, category], name: "idx_dailywin_user_category")
}

model OwnerNote {
  id        String   @id @default(cuid())
  userId    String
  note      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  lastActiveAt DateTime @default(now())
  userAgent    String?
  ipAddress    String?  @db.VarChar(50)
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([lastActiveAt])
  @@index([createdAt])
}

model ScreeningResult {
  id            String   @id @default(cuid())
  userId        String?
  screeningType String   @db.VarChar(50)
  score         Int?
  riskLevel     String?  @db.VarChar(20)
  completedAt   DateTime @default(now())
  answers       Json?
  createdAt     DateTime @default(now())
  user          User?    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([screeningType])
  @@index([riskLevel])
  @@index([completedAt])
}

model SearchQuery {
  id           String   @id @default(cuid())
  userId       String?
  query        String   @db.VarChar(500)
  searchType   String   @db.VarChar(50)
  resultsCount Int?
  createdAt    DateTime @default(now())
  user         User?    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([searchType])
  @@index([query])
  @@index([createdAt])
}

model DataLineageNode {
  id            String            @id @default(cuid())
  datasetId     String?
  name          String            @db.VarChar(255)
  type          LineageNodeType
  metadata      Json?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  upcomingEdges DataLineageEdge[] @relation("SourceNode")
  outgoingEdges DataLineageEdge[] @relation("TargetNode")
  dataset       Dataset?          @relation(fields: [datasetId], references: [id])

  @@index([datasetId])
  @@index([type])
}

model DataLineageEdge {
  id                  String          @id @default(cuid())
  sourceNodeId        String
  targetNodeId        String
  transformationLogic String?
  createdAt           DateTime        @default(now())
  sourceNode          DataLineageNode @relation("SourceNode", fields: [sourceNodeId], references: [id], onDelete: Cascade)
  targetNode          DataLineageNode @relation("TargetNode", fields: [targetNodeId], references: [id], onDelete: Cascade)

  @@index([sourceNodeId])
  @@index([targetNodeId])
}

model DataQualityRule {
  id          String              @id @default(cuid())
  datasetId   String
  fieldName   String?             @db.VarChar(255)
  ruleType    DataQualityRuleType
  name        String              @db.VarChar(255)
  description String?
  criteria    Json
  severity    String              @default("WARNING")
  isActive    Boolean             @default(true)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  executions  DataQualityResult[]
  dataset     Dataset             @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([datasetId])
  @@index([ruleType])
}

model DataQualityResult {
  id                  String          @id @default(cuid())
  ruleId              String
  status              String
  recordsChecked      Int             @default(0)
  failuresFound       Int             @default(0)
  anomalyScore        Float?
  failureSample       Json?
  runDate             DateTime        @default(now())
  executionDurationMs Int?
  rule                DataQualityRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([ruleId])
  @@index([status])
  @@index([runDate])
}

model JobExecution {
  id               String    @id @default(cuid())
  jobName          String    @db.VarChar(255)
  status           String
  source           String?
  recordsProcessed Int       @default(0)
  startedAt        DateTime  @default(now())
  completedAt      DateTime?
  errorLog         String?
  metadata         Json?

  @@index([jobName])
  @@index([status])
  @@index([startedAt])
}

model UserConsent {
  id          String    @id @default(cuid())
  userId      String
  consentType String    @db.VarChar(100)
  version     String    @db.VarChar(20)
  hasGranted  Boolean   @default(false)
  grantedAt   DateTime?
  revokedAt   DateTime?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([consentType])
  @@index([hasGranted])
}

model SensitiveAccessLog {
  id             String   @id @default(cuid())
  adminUserId    String
  datasetName    String   @db.VarChar(255)
  actionType     String
  recordCount    Int?
  filterCriteria Json?
  reason         String?
  accessedAt     DateTime @default(now())
  adminUser      User     @relation(fields: [adminUserId], references: [id], onDelete: Cascade)

  @@index([adminUserId])
  @@index([datasetName])
  @@index([accessedAt])
}

model SecurityAlert {
  id            String    @id @default(cuid())
  userId        String
  alertType     String    @db.VarChar(100)
  severity      String    @db.VarChar(20) // low, medium, high, critical
  details       Json?
  acknowledged  Boolean   @default(false)
  acknowledgedAt DateTime?
  acknowledgedBy String?
  createdAt     DateTime  @default(now())
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([alertType])
  @@index([severity])
  @@index([acknowledged])
  @@index([createdAt])
}

model AACVocabulary {
  id        String      @id @default(cuid())
  userId    String
  label     String      @db.VarChar(100)
  symbol    String      @db.VarChar(255)
  category  AACCategory @default(CUSTOM)
  audioText String?     @db.VarChar(255)
  order     Int         @default(0)
  isActive  Boolean     @default(true)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([category])
  @@index([order])
  @@index([isActive])
}

enum Role {
  PARENT
  THERAPIST
  MODERATOR
  ADMIN
}

enum PostStatus {
  ACTIVE
  REMOVED
  LOCKED
  PINNED
  DRAFT
}

enum CommentStatus {
  ACTIVE
  REMOVED
  HIDDEN
}

enum VoteType {
  POST
  COMMENT
}

enum ReportTargetType {
  POST
  COMMENT
  USER
}

enum ReportReason {
  SPAM
  HARASSMENT
  MISINFO
  SELF_HARM
  INAPPROPRIATE_CONTENT
  OTHER
}

enum ReportStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum ModerationActionType {
  REMOVE
  LOCK
  PIN
  UNPIN
  SHADOWBAN
  UNSHADOWBAN
  WARN
  VERIFY_THERAPIST
  REJECT_VERIFICATION
  MUTE
  UNMUTE
}

enum ProviderSource {
  GOOGLE_PLACES
  OSM
  MANUAL
}

enum ProviderSpecialty {
  ABA
  OT
  SLP
  DEVELOPMENTAL_PEDIATRICS
  PSYCHOLOGIST
  PSYCHIATRIST
  NEURODEVELOPMENTAL
  SPEECH_PATHOLOGY
  OCCUPATIONAL_THERAPY
  BEHAVIORAL_THERAPY
  SOCIAL_WORKER
  COUNSELOR
}

enum ProviderClaimStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NotificationType {
  POST_COMMENT
  COMMENT_REPLY
  POST_LIKE
  COMMENT_LIKE
  MENTION
  FOLLOW
  MESSAGE
  MODERATION_ACTION
  VERIFICATION_REQUEST
  SYSTEM
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
}

enum ConnectionRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum ResourceCategory {
  EDUCATION
  THERAPY
  NUTRITION
  BEHAVIOR
  SLEEP
  SOCIAL_SKILLS
  LEGAL
  FINANCIAL
  COMMUNITY
  OTHER
}

enum DataSensitivity {
  PUBLIC
  INTERNAL
  SENSITIVE
  PII
  PHI
}

enum TherapyType {
  ABA
  OCCUPATIONAL
  SPEECH
  BEHAVIORAL
  PLAY
  SOCIAL_SKILLS
  PHYSICAL
  OTHER
}

enum LineageNodeType {
  SOURCE
  PROCESS
  STORE
  REPORT
}

enum DataQualityRuleType {
  NULL_CHECK
  REGEX_MATCH
  RANGE_CHECK
  FOREIGN_KEY
  ANOMALY_DETECTION
  CUSTOM_SQL
}

enum AACCategory {
  CORE
  FOOD
  SENSORY
  EMERGENCY
  SOCIAL
  ACTIONS
  CUSTOM
}
